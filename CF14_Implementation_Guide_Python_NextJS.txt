# CF14 IMPLEMENTATION GUIDE - PYTHON/NEXT.JS

**Target Stack**: Python CLI + Next.js API + Neo4j  
**CF14 Version**: v2.0 (cf14.core.v2.0)  
**Status**: Implementation companion to normative specification

---

## 0. ARCHITECTURE OVERVIEW

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Python CLI    │◄──►│   Next.js API    │◄──►│    Neo4j DB     │
│                 │    │                  │    │                 │
│ chirality_cli.py│    │ /api/neo4j/*     │    │ Components      │
│ neo4j_admin.py  │    │ /api/chat        │    │ Operations      │
│ semmul.py       │    │ /api/domain      │    │ Provenance      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

**Integration Points:**
- Python tools call Next.js API (localhost:3000)
- Next.js API proxies to Neo4j via driver
- All semantic operations route through API for consistency
- Graph database serves as shared semantic store

---

## 1. PROJECT STRUCTURE

```
project/
├── ontology/
│   ├── cf14.core.v2.0.json          # Core ontology registry
│   └── domains/
│       └── {domain}/
│           └── cf14.domain.{domain}.v1.0.json
├── python/
│   ├── chirality_cli.py             # Main CLI interface
│   ├── neo4j_admin.py              # Database administration
│   ├── semmul.py                   # Semantic operations engine
│   └── cf14/
│       ├── __init__.py
│       ├── ontology.py             # Ontology loading/validation
│       ├── operations.py           # Semantic operation implementations
│       └── client.py               # API client
├── app/api/
│   ├── neo4j/
│   │   ├── ingest/route.ts         # Component ingestion
│   │   ├── query/route.ts          # Graph queries
│   │   └── operation/route.ts      # Semantic operations
│   └── chat/route.ts               # LLM integration
└── lib/
    ├── neo4j.ts                    # Neo4j driver setup
    └── cf14/
        ├── ontology.ts             # Ontology utilities
        └── validation.ts           # Schema validation
```

---

## 2. ONTOLOGY LOADING & VALIDATION

### 2.1 Python Implementation

```python
# cf14/ontology.py
import json
from pathlib import Path
from typing import Dict, Any
from pydantic import BaseModel, ValidationError

class CF14Ontology(BaseModel):
    id: str
    version: str
    stations: List[Dict[str, Any]]
    entities: List[Dict[str, Any]]
    components: List[Dict[str, Any]]
    operations: List[Dict[str, Any]]

def load_ontology(ontology_id: str = "cf14.core.v2.0") -> CF14Ontology:
    """Load and validate CF14 ontology registry"""
    ontology_path = Path(f"ontology/{ontology_id}.json")
    
    if not ontology_path.exists():
        raise FileNotFoundError(f"Ontology not found: {ontology_id}")
    
    with open(ontology_path) as f:
        data = json.load(f)
    
    try:
        return CF14Ontology(**data)
    except ValidationError as e:
        raise ValueError(f"Invalid ontology format: {e}")

def merge_domain_pack(core: CF14Ontology, domain_pack_path: str) -> CF14Ontology:
    """Merge domain pack with core ontology"""
    with open(domain_pack_path) as f:
        domain_data = json.load(f)
    
    # Validate extends field
    if domain_data.get("extends") != core.id:
        raise ValueError(f"Domain pack incompatible with {core.id}")
    
    # Merge domain-specific matrices into core
    merged = core.copy(deep=True)
    if "axiomatic_matrices" in domain_data:
        for matrix_name, matrix_data in domain_data["axiomatic_matrices"].items():
            # Add domain-specific matrix content
            pass
    
    return merged
```

### 2.2 TypeScript Implementation

```typescript
// lib/cf14/ontology.ts
interface CF14Ontology {
  id: string
  version: string
  stations: Station[]
  entities: Entity[]
  components: Component[]
  operations: Operation[]
}

export async function loadOntology(ontologyId = "cf14.core.v2.0"): Promise<CF14Ontology> {
  const response = await fetch(`/ontology/${ontologyId}.json`)
  
  if (!response.ok) {
    throw new Error(`Failed to load ontology: ${ontologyId}`)
  }
  
  const ontology = await response.json()
  
  // Validate against schema
  const validationResult = validateOntologySchema(ontology)
  if (!validationResult.valid) {
    throw new Error(`Invalid ontology: ${validationResult.errors.join(', ')}`)
  }
  
  return ontology
}

export function validateComponent(component: any, ontology: CF14Ontology): boolean {
  const template = ontology.components.find(c => c.name === component.name)
  if (!template) return false
  
  // Validate dimensions match template
  return JSON.stringify(component.dimensions) === JSON.stringify(template.dimensions)
}
```

---

## 3. SEMANTIC OPERATIONS ENGINE

### 3.1 Core Operations Implementation

```python
# cf14/operations.py
from typing import List, Dict, Any
import json
from datetime import datetime
import openai

class SemanticOperation:
    def __init__(self, model_vendor="openai", model_name="gpt-4", model_version="4.0"):
        self.model_vendor = model_vendor
        self.model_name = model_name  
        self.model_version = model_version
        self.client = openai.OpenAI()

    def multiply(self, term_a: str, term_b: str) -> str:
        """Semantic multiplication: A * B -> semantic intersection"""
        prompt = f"""
        Perform semantic multiplication to find the intersection of meanings:
        
        "{term_a}" * "{term_b}"
        
        Return only the single resolved term that represents the unified semantic intersection.
        Examples:
        - "sufficient" * "reason" = "justification"
        - "analysis" * "judgment" = "informed decision"
        """
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
            max_tokens=50
        )
        
        result = response.choices[0].message.content.strip().strip('"')
        
        # Record operation provenance
        self._record_operation("multiplication", [term_a, term_b], result)
        
        return result

    def add(self, terms: List[str]) -> str:
        """Semantic addition: concatenate/fuse terms"""
        prompt = f"""
        Perform semantic addition to fuse these terms into a coherent statement:
        
        Terms: {terms}
        
        Return the fused result as a single coherent expression.
        """
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
            max_tokens=100
        )
        
        result = response.choices[0].message.content.strip().strip('"')
        self._record_operation("addition", terms, result)
        
        return result

    def matrix_multiply(self, matrix_a: List[List[str]], matrix_b: List[List[str]]) -> List[List[str]]:
        """Semantic matrix multiplication: A[3x4] * B[4x4] = C[3x4]"""
        rows_a, cols_a = len(matrix_a), len(matrix_a[0])
        rows_b, cols_b = len(matrix_b), len(matrix_b[0])
        
        if cols_a != rows_b:
            raise ValueError(f"Matrix dimension mismatch: {cols_a} != {rows_b}")
        
        result = []
        for i in range(rows_a):
            row = []
            for j in range(cols_b):
                # Compute C[i,j] = +(*(A[i,1], B[1,j]), *(A[i,2], B[2,j]), ...)
                products = []
                for k in range(cols_a):
                    product = self.multiply(matrix_a[i][k], matrix_b[k][j])
                    products.append(product)
                
                cell_result = self.add(products)
                row.append(cell_result)
            result.append(row)
        
        return result

    def _record_operation(self, op_type: str, inputs: List[str], output: str):
        """Record operation provenance"""
        operation_record = {
            "type": op_type,
            "timestamp": datetime.now().isoformat(),
            "model_vendor": self.model_vendor,
            "model_name": self.model_name,
            "model_version": self.model_version,
            "inputs": inputs,
            "output": output
        }
        
        # Send to Neo4j via API
        import requests
        requests.post("http://localhost:3000/api/neo4j/operation", json=operation_record)
```

### 3.2 Matrix Pipeline Implementation

```python
# cf14/pipeline.py
from .operations import SemanticOperation
from .ontology import load_ontology

class CF14Pipeline:
    def __init__(self, domain_pack_path: str = None):
        self.ontology = load_ontology()
        if domain_pack_path:
            self.ontology = merge_domain_pack(self.ontology, domain_pack_path)
        
        self.operations = SemanticOperation()

    def execute_a_times_b_equals_c(self, matrix_a: List[List[str]], matrix_b: List[List[str]]) -> Dict[str, Any]:
        """Execute the canonical A * B = C operation"""
        
        # Validate input dimensions
        if len(matrix_a) != 3 or len(matrix_a[0]) != 4:
            raise ValueError("Matrix A must be 3x4")
        if len(matrix_b) != 4 or len(matrix_b[0]) != 4:
            raise ValueError("Matrix B must be 4x4")
        
        # Perform semantic matrix multiplication
        matrix_c = self.operations.matrix_multiply(matrix_a, matrix_b)
        
        # Package result with metadata
        result = {
            "component": {
                "id": f"matrix_C_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                "name": "Matrix C (Requirements)",
                "kind": "matrix",
                "station": "Requirements",
                "dimensions": [3, 4],
                "row_labels": ["Normative", "Operative", "Evaluative"],
                "col_labels": ["Necessity", "Sufficiency", "Completeness", "Consistency"],
                "cells": self._format_cells(matrix_c),
                "ontology_id": self.ontology.id,
                "operation_type": "multiplication"
            }
        }
        
        return result

    def _format_cells(self, matrix: List[List[str]]) -> List[Dict[str, Any]]:
        """Format matrix as cell array for Neo4j ingestion"""
        cells = []
        for i, row in enumerate(matrix):
            for j, value in enumerate(row):
                cells.append({
                    "row": i + 1,
                    "col": j + 1,
                    "resolved": value,
                    "operation": "*+"  # multiplication + addition
                })
        return cells
```

---

## 4. API IMPLEMENTATION

### 4.1 Neo4j Integration Routes

```typescript
// app/api/neo4j/ingest/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { neo4jDriver } from '@/lib/neo4j'
import { validateComponent } from '@/lib/cf14/validation'

export async function POST(request: NextRequest) {
  try {
    const data = await request.json()
    const { component } = data
    
    // Validate against ontology
    const isValid = await validateComponent(component)
    if (!isValid) {
      return NextResponse.json({ error: "Invalid component schema" }, { status: 400 })
    }
    
    const session = neo4jDriver.session()
    
    try {
      // Create component node
      const result = await session.run(`
        CREATE (c:Component:Matrix {
          id: $id,
          name: $name,
          kind: $kind,
          station: $station,
          dimensions: $dimensions,
          ontology_id: $ontology_id,
          operation_type: $operation_type,
          ufo_type: 'Endurant'
        })
        RETURN c
      `, component)
      
      // Create cells
      for (const cell of component.cells) {
        await session.run(`
          MATCH (c:Component {id: $component_id})
          CREATE (cell:Cell {
            row: $row,
            col: $col,
            resolved: $resolved,
            operation: $operation,
            ufo_type: 'Mode'
          })
          CREATE (c)-[:HAS_CELL]->(cell)
        `, { ...cell, component_id: component.id })
      }
      
      // Link to station
      await session.run(`
        MATCH (c:Component {id: $component_id})
        MATCH (s:Station {name: $station})
        CREATE (c)-[:AT_STATION]->(s)
      `, { component_id: component.id, station: component.station })
      
      return NextResponse.json({ success: true, component_id: component.id })
      
    } finally {
      await session.close()
    }
    
  } catch (error) {
    console.error('Ingestion error:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

### 4.2 Semantic Operation Route

```typescript
// app/api/neo4j/operation/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { neo4jDriver } from '@/lib/neo4j'

export async function POST(request: NextRequest) {
  try {
    const operation = await request.json()
    
    const session = neo4jDriver.session()
    
    try {
      // Create operation event node
      const result = await session.run(`
        CREATE (op:SemanticOperation {
          type: $type,
          timestamp: $timestamp,
          model_vendor: $model_vendor,
          model_name: $model_name,
          model_version: $model_version,
          operation_id: randomUUID(),
          ufo_type: 'Event'
        })
        RETURN op.operation_id as id
      `, operation)
      
      const operationId = result.records[0].get('id')
      
      // Link input terms
      for (const input of operation.inputs) {
        await session.run(`
          MATCH (op:SemanticOperation {operation_id: $operation_id})
          MERGE (t:Term {value: $value, role: 'raw', ufo_type: 'Mode'})
          CREATE (op)-[:USED_TERM]->(t)
        `, { operation_id: operationId, value: input })
      }
      
      // Link output term
      await session.run(`
        MATCH (op:SemanticOperation {operation_id: $operation_id})
        MERGE (t:Term {value: $value, role: 'resolved', ufo_type: 'Mode'})
        CREATE (op)-[:PRODUCED_TERM]->(t)
      `, { operation_id: operationId, value: operation.output })
      
      return NextResponse.json({ success: true, operation_id: operationId })
      
    } finally {
      await session.close()
    }
    
  } catch (error) {
    console.error('Operation recording error:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

---

## 5. CLI INTEGRATION

### 5.1 Updated chirality_cli.py

```python
#!/usr/bin/env python3
import click
import json
from pathlib import Path
from cf14.pipeline import CF14Pipeline
from cf14.client import CF14Client

@click.group()
def cli():
    """CF14 Chirality Framework CLI v2.0"""
    pass

@cli.command()
@click.option('--domain-pack', help='Path to domain-specific ontology pack')
@click.option('--out', help='Output file path')
def semantic_matrix_c(domain_pack, out):
    """Generate Requirements matrix (C = A * B)"""
    
    # Load pipeline with domain pack
    pipeline = CF14Pipeline(domain_pack_path=domain_pack)
    
    # Get matrices A and B from domain pack or defaults
    matrix_a, matrix_b = load_axiomatic_matrices(domain_pack)
    
    # Execute semantic operation
    result = pipeline.execute_a_times_b_equals_c(matrix_a, matrix_b)
    
    # Store in Neo4j via API
    client = CF14Client()
    response = client.ingest_component(result)
    
    if response.get('success'):
        click.echo(f"Matrix C generated and stored: {response['component_id']}")
        
        if out:
            with open(out, 'w') as f:
                json.dump(result, f, indent=2)
            click.echo(f"Output saved to: {out}")
    else:
        click.echo(f"Error: {response.get('error')}")

def load_axiomatic_matrices(domain_pack_path):
    """Load matrices A and B from domain pack"""
    if not domain_pack_path:
        # Return default test matrices
        matrix_a = [
            ["Direction", "Implementation", "Evaluation", "Assessment"],
            ["Leadership", "Execution", "Decision-making", "Quality Control"],
            ["Standards", "Performance", "Feedback", "Refinement"]
        ]
        matrix_b = [
            ["Essential Facts", "Adequate Inputs", "Comprehensive Records", "Reliable Records"],
            ["Critical Context", "Sufficient Detail", "Holistic View", "Congruent Patterns"],
            ["Fundamental Understanding", "Adequate Insight", "Full Comprehension", "Coherent Framework"],
            ["Vital Judgment", "Sound Reasoning", "Thorough Prudence", "Harmonious Principles"]
        ]
        return matrix_a, matrix_b
    
    with open(domain_pack_path) as f:
        domain_data = json.load(f)
    
    matrix_a = domain_data["axiomatic_matrices"]["A"]["cells"]
    matrix_b = domain_data["axiomatic_matrices"]["B"]["cells"]
    
    return matrix_a, matrix_b

if __name__ == '__main__':
    cli()
```

### 5.2 API Client

```python
# cf14/client.py
import requests
from typing import Dict, Any

class CF14Client:
    def __init__(self, base_url: str = "http://localhost:3000"):
        self.base_url = base_url

    def ingest_component(self, component_data: Dict[str, Any]) -> Dict[str, Any]:
        """Ingest component into Neo4j via API"""
        response = requests.post(
            f"{self.base_url}/api/neo4j/ingest",
            json=component_data,
            headers={"Content-Type": "application/json"}
        )
        return response.json()

    def query_components(self, station: str = None) -> Dict[str, Any]:
        """Query components by station"""
        params = {"station": station} if station else {}
        response = requests.get(
            f"{self.base_url}/api/neo4j/query",
            params=params
        )
        return response.json()

    def get_semantic_operations(self, component_id: str) -> Dict[str, Any]:
        """Get operation provenance for component"""
        response = requests.get(
            f"{self.base_url}/api/neo4j/operation",
            params={"component_id": component_id}
        )
        return response.json()
```

---

## 6. SETUP & DEPLOYMENT

### 6.1 Environment Setup

```bash
# Install Python dependencies
pip install click openai requests pydantic

# Install Next.js dependencies  
npm install neo4j-driver

# Set environment variables
export OPENAI_API_KEY="your-key-here"
export NEO4J_URI="bolt://localhost:7687"
export NEO4J_USER="neo4j"
export NEO4J_PASSWORD="password"
```

### 6.2 Neo4j Schema Initialization

```cypher
-- Create constraints and indexes
CREATE CONSTRAINT station_name IF NOT EXISTS FOR (s:Station) REQUIRE s.name IS UNIQUE;
CREATE CONSTRAINT component_id IF NOT EXISTS FOR (c:Component) REQUIRE c.id IS UNIQUE;
CREATE INDEX term_value IF NOT EXISTS FOR (t:Term) ON (t.value);
CREATE INDEX operation_timestamp IF NOT EXISTS FOR (op:SemanticOperation) ON (op.timestamp);

-- Initialize stations
UNWIND [
  {p:1,n:'Problem Statement'},{p:2,n:'Requirements'},{p:3,n:'Objectives'},
  {p:4,n:'Verification'},{p:5,n:'Validation'},{p:6,n:'Evaluation'},
  {p:7,n:'Assessment'},{p:8,n:'Implementation'},{p:9,n:'Reflection'},
  {p:10,n:'Resolution'}
] AS s
MERGE (st:Station {name:s.n}) SET st.position=s.p;

-- Create station progression
MATCH (a:Station),(b:Station) WHERE b.position = a.position + 1
MERGE (a)-[:NEXT]->(b);
```

### 6.3 Usage Examples

```bash
# Start Next.js development server
npm run dev

# Generate Matrix C with default test data
python chirality_cli.py semantic-matrix-c --out matrix_c.json

# Generate with domain pack
python chirality_cli.py semantic-matrix-c \
  --domain-pack domains/software_eng/cf14.domain.software_eng.v1.0.json \
  --out software_matrix_c.json

# Query stored components
python -c "
from cf14.client import CF14Client
client = CF14Client()
result = client.query_components(station='Requirements')
print(result)
"
```

---

## 7. TESTING & VALIDATION

### 7.1 Unit Tests

```python
# tests/test_operations.py
import pytest
from cf14.operations import SemanticOperation

def test_semantic_multiplication():
    ops = SemanticOperation()
    result = ops.multiply("sufficient", "reason")
    assert isinstance(result, str)
    assert len(result) > 0

def test_matrix_multiplication():
    ops = SemanticOperation()
    a = [["term1", "term2", "term3", "term4"]] * 3
    b = [["termA"], ["termB"], ["termC"], ["termD"]]
    
    result = ops.matrix_multiply(a, b)
    assert len(result) == 3
    assert len(result[0]) == 1
```

### 7.2 Integration Tests

```python
# tests/test_pipeline.py
import pytest
from cf14.pipeline import CF14Pipeline

def test_a_times_b_equals_c():
    pipeline = CF14Pipeline()
    
    matrix_a = [["Direction", "Implementation", "Evaluation", "Assessment"]] * 3
    matrix_b = [["Essential Facts", "Adequate Inputs", "Comprehensive Records", "Reliable Records"]] * 4
    
    result = pipeline.execute_a_times_b_equals_c(matrix_a, matrix_b)
    
    assert result["component"]["kind"] == "matrix"
    assert result["component"]["station"] == "Requirements"
    assert len(result["component"]["cells"]) == 12  # 3x4 matrix
```

---

## 8. MONITORING & DEBUGGING

### 8.1 Operation Logging

```python
# Add to cf14/operations.py
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class SemanticOperation:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def multiply(self, term_a: str, term_b: str) -> str:
        self.logger.info(f"Multiplying: '{term_a}' * '{term_b}'")
        result = # ... operation logic
        self.logger.info(f"Result: '{result}'")
        return result
```

### 8.2 API Monitoring

```typescript
// lib/monitoring.ts
export function logAPICall(endpoint: string, data: any, response: any) {
  console.log(`[${new Date().toISOString()}] ${endpoint}`, {
    request: data,
    response: response,
    success: !response.error
  })
}
```

---

## 9. PRODUCTION CONSIDERATIONS

### 9.1 Error Handling

- Implement retry logic for OpenAI API calls
- Add circuit breaker for Neo4j connections
- Validate all inputs against ontology schema
- Log all errors with operation context

### 9.2 Performance Optimization

- Cache ontology registry in memory
- Use connection pooling for Neo4j
- Batch cell insertions for large matrices
- Implement async operations for Python client

### 9.3 Security

- Validate all API inputs against JSON schemas
- Sanitize Neo4j queries to prevent injection
- Rate limit semantic operations
- Store API keys securely (environment variables)

---

**END OF IMPLEMENTATION GUIDE**