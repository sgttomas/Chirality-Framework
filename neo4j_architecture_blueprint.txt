# CF14 → Neo4j Architecture Blueprint (Draft)

## 1) High‑level Data Flow

```
[Author/CLI Prompt Runs]
        │
        ▼
Python (chirality_cli.py) ──► JSON (Component/Cells)
        │                        │
        │  (real‑time POST)      │ (optional local file drop)
        ▼                        ▼
Next.js API (/api/neo4j/ingest[‑v2])  ◄── Batch Ingestion Script (optional)
        │
        ▼
Neo4j (Aura or Local)
        │
        ├─ Query API (/api/neo4j/query[‑simple])
        ▼
UI: /instantiate + /matrices
```

---

## 2) Graph Schema (current MVP)

**Nodes**

* `(:Station {id:int, name:string})`
* `(:Component {id:string, name:string, kind:string, station:int, dimensions:[int,int], operation_type?:string, ontology_id?:string, metadata?:map, cf14_version?:string, domain?:string})`
* `(:Axis {name:string, position:int, labels:[string]})`
  *position: 0 = rows, 1 = cols*
* `(:Cell {component_id:string, row:int, col:int, resolved?:string, raw_terms?:[string], operation?:string, semantic_derivation?:string, notes?:string})`
* `(:Term {value:string, type?:string})`

**Relationships**

* `(:Component)-[:AT_STATION]->(:Station)`
* `(:Component)-[:HAS_AXIS]->(:Axis)`
* `(:Component)-[:HAS_CELL]->(:Cell)`
* `(:Cell)-[:RESOLVES_TO]->(:Term)`

> This keeps the MVP purely graph‑shaped while remaining extensible (you can later model hyperedges as first‑class nodes if needed).

---

## 3) Constraints & Indexes (Cypher)

```cypher
// Uniqueness
CREATE CONSTRAINT station_id IF NOT EXISTS FOR (s:Station) REQUIRE s.id IS UNIQUE;
CREATE CONSTRAINT component_id IF NOT EXISTS FOR (c:Component) REQUIRE c.id IS UNIQUE;
CREATE CONSTRAINT term_value IF NOT EXISTS FOR (t:Term) REQUIRE t.value IS UNIQUE;

// Helpful indexes (lookup & filtering)
CREATE INDEX component_station IF NOT EXISTS FOR (c:Component) ON (c.station);
CREATE INDEX cell_component_row_col IF NOT EXISTS FOR (cell:Cell) ON (cell.component_id, cell.row, cell.col);
```

---

## 4) Ingestion API Contract (JSON → Graph)

**Endpoint**: `POST /api/neo4j/ingest`

**Payload (simplified)**

```json
{
  "component": {
    "id": "C-2025-08-13-001",
    "name": "Matrix C",
    "kind": "matrix",
    "station": 3,
    "dimensions": [4,4],
    "row_names": ["Normative","Operative","Evaluative","…"],
    "column_names": ["Data","Information","Knowledge","Wisdom"],
    "operation_type": "CF14 v2.1.1",
    "ontology_id": "cf14/c",
    "metadata": {"topic":"…","source":"chirality_cli"},
    "cells": [
      {"row":0,"col":0,"resolved":"…","raw_terms":["…"],"operation":"…","semantic_derivation":"…"},
      {"row":0,"col":1,"resolved":"…"}
    ]
  }
}
```

**Server behavior (transactional)**

1. `MERGE` component by `id`; set all scalar/map props.
2. `MERGE` each `Cell` by (`component_id`,`row`,`col`); set props.
3. `MERGE (component)-[:HAS_CELL]->(cell)`.
4. `MERGE` `Station` by id; link `(:Component)-[:AT_STATION]->(:Station)`.
5. (Optional) For each distinct `resolved`/`raw_terms`, `MERGE` `(:Term)` and connect via `[:RESOLVES_TO]`.

**Idempotency**: Upserts by `component.id` and cell coordinates ensure safe retries.

---

## 5) Example Queries (read side)

**A. List components by station**

```cypher
MATCH (c:Component)-[:AT_STATION]->(s:Station {id:3})
RETURN c ORDER BY c.name;
```

**B. Rebuild a matrix payload for UI**

```cypher
MATCH (c:Component {id:$id})-[:HAS_CELL]->(cell)
OPTIONAL MATCH (cell)-[:RESOLVES_TO]->(t:Term)
WITH c, cell, t
ORDER BY cell.row, cell.col
RETURN c {
  .id, .name, .kind, .station, .dimensions,
  row_labels: c.row_names, col_labels: c.column_names,
  cells: collect({row:cell.row,col:cell.col,resolved:cell.resolved,term:t.value})
} AS component;
```

**C. Find ambiguous/empty cells**

```cypher
MATCH (:Component {id:$id})-[:HAS_CELL]->(cell)
WHERE coalesce(cell.resolved, '') = ''
RETURN cell.row, cell.col LIMIT 50;
```

**D. Term‑centric exploration**

```cypher
MATCH (t:Term {value:$value})<-[:RESOLVES_TO]-(cell:Cell)<-[:HAS_CELL]-(c:Component)
RETURN c.id AS component, cell.row AS r, cell.col AS c, t.value AS term
ORDER BY component, r, c;
```

---

## 6) Operational Concerns

**Id strategy**

* Components: `C-<date>-<seq>` or ULIDs to make client‑side generation trivial.
* Cells: no explicit `id`; coordinate + `component_id` is the natural key (indexed).

**Versioning**

* Keep `cf14_version` on `Component`. If you need historical matrices, store new `Component` ids and link with `(:Component)-[:REPLACES]->(:Component)`.

**Validation**

* API should check: dimensions match max(row,co
